<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitView</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      -webkit-app-region: drag;
    }

    button, input, a {
      -webkit-app-region: no-drag;
    }

    .header {
      background: #3c1053;
      padding: 16px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 20px;
      font-weight: 600;
      color: #fff;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .refresh-indicator {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
    }

    .refresh-indicator.loading {
      color: #e87722;
    }

    .settings-btn {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      font-size: 18px;
      padding: 4px 8px;
    }

    .settings-btn:hover {
      color: #fff;
    }

    .status-bar {
      background: #16213e;
      padding: 12px 24px;
      display: flex;
      gap: 24px;
      border-bottom: 1px solid #0f3460;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .status-dot.running {
      background: #3498db;
      animation: pulse 1.5s infinite;
    }

    .status-dot.success {
      background: #27ae60;
    }

    .status-dot.failure {
      background: #e74c3c;
    }

    .status-dot.queued {
      background: #f39c12;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .main-content {
      padding: 24px;
      overflow-y: auto;
      height: calc(100vh - 110px);
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: rgba(255, 255, 255, 0.5);
    }

    .empty-state h2 {
      font-size: 18px;
      margin-bottom: 8px;
    }

    .repo-group {
      background: #16213e;
      border-radius: 8px;
      margin-bottom: 16px;
      overflow: hidden;
    }

    .repo-header {
      background: #0f3460;
      padding: 12px 16px;
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .repo-header a {
      color: #e87722;
      text-decoration: none;
    }

    .repo-header a:hover {
      text-decoration: underline;
    }

    .workflow-run {
      padding: 12px 16px;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .workflow-run:last-child {
      border-bottom: none;
    }

    .workflow-status {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .workflow-status.queued {
      background: #f39c12;
    }

    .workflow-status.in_progress {
      background: #3498db;
      animation: pulse 1.5s infinite;
    }

    .workflow-status.success {
      background: #27ae60;
    }

    .workflow-status.failure {
      background: #e74c3c;
    }

    .workflow-status.cancelled {
      background: #95a5a6;
    }

    .workflow-info {
      flex: 1;
      min-width: 0;
    }

    .workflow-name {
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .workflow-name a {
      color: #fff;
      text-decoration: none;
    }

    .workflow-name a:hover {
      color: #e87722;
    }

    .workflow-meta {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      display: flex;
      gap: 12px;
    }

    .workflow-time {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      white-space: nowrap;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      -webkit-app-region: no-drag;
    }

    .modal-overlay.hidden {
      display: none;
    }

    .modal {
      background: #16213e;
      border-radius: 12px;
      padding: 32px;
      width: 90%;
      max-width: 450px;
    }

    .modal h2 {
      font-size: 20px;
      margin-bottom: 8px;
      color: #fff;
    }

    .modal p {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .modal label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
    }

    .modal input {
      width: 100%;
      padding: 12px;
      border: 1px solid #0f3460;
      border-radius: 6px;
      background: #1a1a2e;
      color: #fff;
      font-size: 14px;
      margin-bottom: 24px;
    }

    .modal input:focus {
      outline: none;
      border-color: #e87722;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border: none;
    }

    .btn-primary {
      background: #e87722;
      color: #fff;
    }

    .btn-primary:hover {
      background: #d46a1a;
    }

    .btn-secondary {
      background: #0f3460;
      color: #fff;
    }

    .btn-secondary:hover {
      background: #1a4a7a;
    }

    .error-message {
      background: rgba(231, 76, 60, 0.2);
      border: 1px solid #e74c3c;
      color: #e74c3c;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 16px;
      font-size: 14px;
    }

    .error-message.hidden {
      display: none;
    }

    .setting-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 0;
      border-top: 1px solid #0f3460;
      margin-top: 16px;
    }

    .setting-label {
      font-size: 14px;
    }

    .toggle {
      position: relative;
      width: 44px;
      height: 24px;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0f3460;
      border-radius: 24px;
      transition: 0.3s;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      border-radius: 50%;
      transition: 0.3s;
    }

    .toggle input:checked + .toggle-slider {
      background: #e87722;
    }

    .toggle input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }

    .time-slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      -webkit-app-region: no-drag;
    }

    .time-slider-label {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }

    .time-slider {
      -webkit-appearance: none;
      width: 100px;
      height: 4px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }

    .time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #e87722;
      cursor: pointer;
    }

    .time-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #e87722;
      cursor: pointer;
      border: none;
    }

    /* Repo filter modal */
    .modal.wide {
      max-width: 600px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }

    .repo-list-container {
      flex: 1;
      overflow-y: auto;
      margin: 16px 0;
      border: 1px solid #0f3460;
      border-radius: 6px;
      max-height: 400px;
    }

    .repo-list-item {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid #0f3460;
      cursor: pointer;
    }

    .repo-list-item:last-child {
      border-bottom: none;
    }

    .repo-list-item:hover {
      background: rgba(232, 119, 34, 0.1);
    }

    .repo-list-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin-right: 12px;
      cursor: pointer;
      accent-color: #e87722;
    }

    .repo-list-item label {
      flex: 1;
      cursor: pointer;
      margin: 0;
      font-size: 14px;
    }

    .repo-filter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .repo-filter-header h2 {
      margin: 0;
    }

    .refresh-repos-btn {
      background: none;
      border: 1px solid #0f3460;
      color: rgba(255, 255, 255, 0.7);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    .refresh-repos-btn:hover {
      border-color: #e87722;
      color: #e87722;
    }

    .repo-search {
      margin-bottom: 0;
    }

    .selected-count {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>GitView</h1>
    <div class="header-right">
      <div class="time-slider-container">
        <span class="time-slider-label" id="timeSliderLabel">30m</span>
        <input type="range" class="time-slider" id="timeSlider" min="30" max="180" step="15" value="30">
      </div>
      <span class="refresh-indicator" id="refreshIndicator">Last updated: --:--</span>
      <button class="settings-btn" id="repoFilterBtn" title="Filter Repositories">&#128202;</button>
      <button class="settings-btn" id="settingsBtn" title="Settings">&#9881;</button>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-item">
      <span class="status-dot running"></span>
      <span>Running: <strong id="runningCount">0</strong></span>
    </div>
    <div class="status-item">
      <span class="status-dot success"></span>
      <span>Success: <strong id="successCount">0</strong></span>
    </div>
    <div class="status-item">
      <span class="status-dot failure"></span>
      <span>Failed: <strong id="failedCount">0</strong></span>
    </div>
    <div class="status-item">
      <span class="status-dot queued"></span>
      <span>Queued: <strong id="queuedCount">0</strong></span>
    </div>
  </div>

  <div class="main-content" id="mainContent">
    <div class="empty-state">
      <h2>Loading...</h2>
      <p>Fetching workflow runs from your repositories</p>
    </div>
  </div>

  <div class="modal-overlay hidden" id="tokenModal">
    <div class="modal">
      <h2>Setup GitHub Token</h2>
      <p>Enter your GitHub Personal Access Token with <code>repo</code> and <code>actions:read</code> scopes to monitor your workflow runs.</p>
      <div class="error-message hidden" id="tokenError"></div>
      <label for="tokenInput">Personal Access Token</label>
      <input type="password" id="tokenInput" placeholder="ghp_xxxxxxxxxxxx">
      <div class="setting-row">
        <span class="setting-label">Start on login</span>
        <label class="toggle">
          <input type="checkbox" id="autoLaunchToggle">
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="modal-buttons">
        <button class="btn btn-secondary" id="cancelTokenBtn">Cancel</button>
        <button class="btn btn-primary" id="saveTokenBtn">Save Token</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay hidden" id="repoFilterModal">
    <div class="modal wide">
      <div class="repo-filter-header">
        <h2>Filter Repositories</h2>
        <button class="refresh-repos-btn" id="refreshReposBtn">Refresh List</button>
      </div>
      <p>Select which repositories to monitor. Only selected repos will be checked for workflow runs.</p>
      <input type="text" class="repo-search" id="repoSearch" placeholder="Search repositories...">
      <div class="repo-list-container" id="repoListContainer">
        <div class="empty-state">Loading repositories...</div>
      </div>
      <div class="selected-count" id="selectedCount">0 repositories selected</div>
      <div class="modal-buttons">
        <button class="btn btn-secondary" id="cancelRepoFilterBtn">Cancel</button>
        <button class="btn btn-primary" id="saveRepoFilterBtn">Save</button>
      </div>
    </div>
  </div>

  <script>
    const GITHUB_API = 'https://api.github.com';
    const REFRESH_INTERVAL = 90000; // 90 seconds
    const REPO_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

    let token = localStorage.getItem('github_token');
    let timeWindowMinutes = parseInt(localStorage.getItem('time_window_minutes')) || 30;
    let selectedRepos = JSON.parse(localStorage.getItem('selected_repos')) || [];
    let cachedRepos = JSON.parse(localStorage.getItem('cached_repos')) || [];
    let repoCacheTime = parseInt(localStorage.getItem('repo_cache_time')) || 0;
    let tempSelectedRepos = []; // For the filter modal
    let refreshTimer = null;

    // DOM Elements
    const mainContent = document.getElementById('mainContent');
    const tokenModal = document.getElementById('tokenModal');
    const tokenInput = document.getElementById('tokenInput');
    const tokenError = document.getElementById('tokenError');
    const saveTokenBtn = document.getElementById('saveTokenBtn');
    const cancelTokenBtn = document.getElementById('cancelTokenBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const refreshIndicator = document.getElementById('refreshIndicator');
    const runningCount = document.getElementById('runningCount');
    const successCount = document.getElementById('successCount');
    const failedCount = document.getElementById('failedCount');
    const queuedCount = document.getElementById('queuedCount');

    // Initialize
    if (!token) {
      showTokenModal();
    } else {
      startMonitoring();
    }

    const autoLaunchToggle = document.getElementById('autoLaunchToggle');
    const timeSlider = document.getElementById('timeSlider');
    const timeSliderLabel = document.getElementById('timeSliderLabel');
    const repoFilterBtn = document.getElementById('repoFilterBtn');
    const repoFilterModal = document.getElementById('repoFilterModal');
    const repoListContainer = document.getElementById('repoListContainer');
    const repoSearch = document.getElementById('repoSearch');
    const selectedCountEl = document.getElementById('selectedCount');
    const refreshReposBtn = document.getElementById('refreshReposBtn');
    const saveRepoFilterBtn = document.getElementById('saveRepoFilterBtn');
    const cancelRepoFilterBtn = document.getElementById('cancelRepoFilterBtn');

    // Initialize time slider
    timeSlider.value = timeWindowMinutes;
    updateTimeSliderLabel();

    function updateTimeSliderLabel() {
      const mins = parseInt(timeSlider.value);
      if (mins >= 60) {
        const hours = mins / 60;
        timeSliderLabel.textContent = hours === 1 ? '1hr' : `${hours}hrs`;
      } else {
        timeSliderLabel.textContent = `${mins}m`;
      }
    }

    // Event Listeners
    saveTokenBtn.addEventListener('click', saveToken);
    cancelTokenBtn.addEventListener('click', hideTokenModal);
    settingsBtn.addEventListener('click', showTokenModal);
    tokenInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') saveToken();
    });
    autoLaunchToggle.addEventListener('change', async (e) => {
      if (window.electronAPI) {
        await window.electronAPI.setAutoLaunch(e.target.checked);
      }
    });
    timeSlider.addEventListener('input', () => {
      updateTimeSliderLabel();
    });
    timeSlider.addEventListener('change', () => {
      timeWindowMinutes = parseInt(timeSlider.value);
      localStorage.setItem('time_window_minutes', timeWindowMinutes);
      if (token) {
        fetchWorkflowRuns();
      }
    });

    // Repo filter event listeners
    repoFilterBtn.addEventListener('click', showRepoFilterModal);
    cancelRepoFilterBtn.addEventListener('click', () => repoFilterModal.classList.add('hidden'));
    saveRepoFilterBtn.addEventListener('click', saveRepoFilter);
    refreshReposBtn.addEventListener('click', () => loadRepoList(true));
    repoSearch.addEventListener('input', filterRepoList);

    async function showRepoFilterModal() {
      repoFilterModal.classList.remove('hidden');
      tempSelectedRepos = [...selectedRepos];
      repoSearch.value = '';
      await loadRepoList(false);
    }

    async function loadRepoList(forceRefresh) {
      const now = Date.now();
      const cacheValid = cachedRepos.length > 0 && (now - repoCacheTime) < REPO_CACHE_DURATION;

      if (!cacheValid || forceRefresh) {
        repoListContainer.innerHTML = '<div class="empty-state">Loading repositories...</div>';
        try {
          cachedRepos = await fetchAllRepos();
          repoCacheTime = now;
          localStorage.setItem('cached_repos', JSON.stringify(cachedRepos));
          localStorage.setItem('repo_cache_time', repoCacheTime.toString());
        } catch (error) {
          repoListContainer.innerHTML = '<div class="empty-state">Error loading repositories</div>';
          return;
        }
      }

      renderRepoList(cachedRepos);
    }

    function renderRepoList(repos) {
      const searchTerm = repoSearch.value.toLowerCase();
      const filtered = repos.filter(r => r.full_name.toLowerCase().includes(searchTerm));

      if (filtered.length === 0) {
        repoListContainer.innerHTML = '<div class="empty-state">No repositories found</div>';
        return;
      }

      repoListContainer.innerHTML = filtered.map(repo => {
        const checked = tempSelectedRepos.includes(repo.full_name) ? 'checked' : '';
        return `
          <div class="repo-list-item" data-repo="${repo.full_name}">
            <input type="checkbox" id="repo-${repo.id}" ${checked}>
            <label for="repo-${repo.id}">${repo.full_name}</label>
          </div>
        `;
      }).join('');

      // Add click handlers
      repoListContainer.querySelectorAll('.repo-list-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (e.target.tagName !== 'INPUT') {
            const checkbox = item.querySelector('input');
            checkbox.checked = !checkbox.checked;
          }
          const repoName = item.dataset.repo;
          if (item.querySelector('input').checked) {
            if (!tempSelectedRepos.includes(repoName)) {
              tempSelectedRepos.push(repoName);
            }
          } else {
            tempSelectedRepos = tempSelectedRepos.filter(r => r !== repoName);
          }
          updateSelectedCount();
        });
      });

      updateSelectedCount();
    }

    function filterRepoList() {
      renderRepoList(cachedRepos);
    }

    function updateSelectedCount() {
      const count = tempSelectedRepos.length;
      selectedCountEl.textContent = count === 0
        ? 'All repositories (no filter)'
        : `${count} repositor${count === 1 ? 'y' : 'ies'} selected`;
    }

    function saveRepoFilter() {
      selectedRepos = [...tempSelectedRepos];
      localStorage.setItem('selected_repos', JSON.stringify(selectedRepos));
      repoFilterModal.classList.add('hidden');
      if (token) {
        fetchWorkflowRuns();
      }
    }

    async function fetchAllRepos() {
      const repos = [];
      let page = 1;
      let hasMore = true;

      while (hasMore) {
        const response = await fetch(`${GITHUB_API}/user/repos?per_page=100&page=${page}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        repos.push(...data);
        hasMore = data.length === 100;
        page++;
      }

      return repos.sort((a, b) => a.full_name.localeCompare(b.full_name));
    }

    async function showTokenModal() {
      tokenModal.classList.remove('hidden');
      tokenInput.value = token || '';
      tokenError.classList.add('hidden');
      tokenInput.focus();

      // Load auto-launch state
      if (window.electronAPI) {
        const isEnabled = await window.electronAPI.getAutoLaunch();
        autoLaunchToggle.checked = isEnabled;
      }
    }

    function hideTokenModal() {
      if (token) {
        tokenModal.classList.add('hidden');
      }
    }

    async function saveToken() {
      const newToken = tokenInput.value.trim();
      if (!newToken) {
        showError('Please enter a token');
        return;
      }

      // Validate token
      try {
        const response = await fetch(`${GITHUB_API}/user`, {
          headers: {
            'Authorization': `Bearer ${newToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });

        if (response.status === 401) {
          showError('Invalid token. Please check and try again.');
          return;
        }

        if (response.status === 403) {
          // Rate limited but token is valid - accept it
          console.warn('Rate limited during token validation, accepting token');
        } else if (!response.ok) {
          showError(`GitHub API error: ${response.status}`);
          return;
        }

        token = newToken;
        localStorage.setItem('github_token', token);
        tokenModal.classList.add('hidden');
        startMonitoring();
      } catch (error) {
        showError('Network error. Please check your connection.');
      }
    }

    function showError(message) {
      tokenError.textContent = message;
      tokenError.classList.remove('hidden');
    }

    function startMonitoring() {
      fetchWorkflowRuns();
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(fetchWorkflowRuns, REFRESH_INTERVAL);
    }

    async function fetchWorkflowRuns() {
      refreshIndicator.textContent = 'Refreshing...';
      refreshIndicator.classList.add('loading');

      try {
        // Get repos to check - either selected repos or prompt to select
        let reposToCheck = [];

        if (selectedRepos.length > 0) {
          // Use selected repos
          reposToCheck = selectedRepos.map(fullName => ({ full_name: fullName, html_url: `https://github.com/${fullName}` }));
        } else {
          // No repos selected - show empty state prompting to select
          mainContent.innerHTML = `
            <div class="empty-state">
              <h2>No repositories selected</h2>
              <p>Click the filter icon in the header to select which repositories to monitor</p>
            </div>
          `;
          refreshIndicator.textContent = 'No repos selected';
          refreshIndicator.classList.remove('loading');
          updateCounts([]);
          return;
        }

        // Get time threshold
        const timeThreshold = new Date(Date.now() - timeWindowMinutes * 60 * 1000);
        const timeString = timeThreshold.toISOString();

        // Fetch workflow runs for each repo
        const allRuns = [];
        const batchPromises = reposToCheck.map(repo => fetchRepoRuns(repo, timeString));
        const batchResults = await Promise.all(batchPromises);
        allRuns.push(...batchResults.flat());

        // Group by repository
        const grouped = groupByRepo(allRuns);

        // Update counts
        updateCounts(allRuns);

        // Render
        renderWorkflows(grouped);

        // Update refresh indicator
        const now = new Date();
        refreshIndicator.textContent = `Last updated: ${now.toLocaleTimeString()}`;
        refreshIndicator.classList.remove('loading');
      } catch (error) {
        console.error('Error fetching workflow runs:', error);
        refreshIndicator.textContent = 'Error refreshing';
        refreshIndicator.classList.remove('loading');

        if (error.message === 'Unauthorized') {
          token = null;
          localStorage.removeItem('github_token');
          showTokenModal();
        }
      }
    }

    async function fetchRepoRuns(repo, timeString) {
      try {
        const response = await fetch(
          `${GITHUB_API}/repos/${repo.full_name}/actions/runs?created=>${timeString}&per_page=100`,
          {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          }
        );

        if (!response.ok) {
          return [];
        }

        const data = await response.json();
        return data.workflow_runs.map(run => ({
          ...run,
          repo_name: repo.full_name,
          repo_url: repo.html_url
        }));
      } catch (error) {
        return [];
      }
    }

    function groupByRepo(runs) {
      const grouped = {};

      runs.forEach(run => {
        if (!grouped[run.repo_name]) {
          grouped[run.repo_name] = {
            name: run.repo_name,
            url: run.repo_url,
            runs: []
          };
        }
        grouped[run.repo_name].runs.push(run);
      });

      // Sort runs within each repo by created_at
      Object.values(grouped).forEach(repo => {
        repo.runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
      });

      // Sort repos by most recent activity
      return Object.values(grouped).sort((a, b) => {
        const aLatest = new Date(a.runs[0]?.created_at || 0);
        const bLatest = new Date(b.runs[0]?.created_at || 0);
        return bLatest - aLatest;
      });
    }

    function updateCounts(runs) {
      const counts = {
        running: 0,
        success: 0,
        failure: 0,
        queued: 0
      };

      runs.forEach(run => {
        if (run.status === 'queued') {
          counts.queued++;
        } else if (run.status === 'in_progress') {
          counts.running++;
        } else if (run.status === 'completed') {
          if (run.conclusion === 'success') {
            counts.success++;
          } else if (run.conclusion === 'failure') {
            counts.failure++;
          }
        }
      });

      runningCount.textContent = counts.running;
      successCount.textContent = counts.success;
      failedCount.textContent = counts.failure;
      queuedCount.textContent = counts.queued;
    }

    function renderWorkflows(grouped) {
      if (grouped.length === 0) {
        mainContent.innerHTML = `
          <div class="empty-state">
            <h2>No workflow runs found</h2>
            <p>No workflow runs in the last ${timeWindowMinutes} minutes across your repositories</p>
          </div>
        `;
        return;
      }

      mainContent.innerHTML = grouped.map(repo => `
        <div class="repo-group">
          <div class="repo-header">
            <span>&#128193;</span>
            <a href="${repo.url}" target="_blank">${repo.name}</a>
          </div>
          ${repo.runs.map(run => renderWorkflowRun(run)).join('')}
        </div>
      `).join('');
    }

    function renderWorkflowRun(run) {
      const status = getRunStatus(run);
      const timeAgo = getTimeAgo(new Date(run.created_at));

      return `
        <div class="workflow-run">
          <div class="workflow-status ${status}"></div>
          <div class="workflow-info">
            <div class="workflow-name">
              <a href="${run.html_url}" target="_blank">${run.name}</a>
            </div>
            <div class="workflow-meta">
              <span>${run.head_branch}</span>
              <span>#${run.run_number}</span>
            </div>
          </div>
          <div class="workflow-time">${timeAgo}</div>
        </div>
      `;
    }

    function getRunStatus(run) {
      if (run.status === 'queued') return 'queued';
      if (run.status === 'in_progress') return 'in_progress';
      if (run.status === 'completed') {
        if (run.conclusion === 'success') return 'success';
        if (run.conclusion === 'failure') return 'failure';
        if (run.conclusion === 'cancelled') return 'cancelled';
      }
      return 'queued';
    }

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);

      if (seconds < 60) return 'Just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      return `${Math.floor(seconds / 86400)}d ago`;
    }
  </script>
</body>
</html>
